using System.Text;
using System.Text.RegularExpressions;

var repoRoot = FindRepoRoot();
var templatesRoot = Path.Combine(repoRoot, "externals", "submodel-templates", "published");
var outputRoot = Path.Combine(repoRoot, "src", "FluentAas.Submodels", "Submodel");
var resourcesRoot = Path.Combine(repoRoot, "src", "FluentAas.Submodels", "Resources");

Directory.CreateDirectory(outputRoot);
Directory.CreateDirectory(resourcesRoot);

Console.WriteLine($"Templates root:  {templatesRoot}");
Console.WriteLine($"Output root:     {outputRoot}");
Console.WriteLine($"Resources root:  {resourcesRoot}");

// 1. Alle JSON-Dateien im published-Ordner finden
var jsonFiles = Directory.EnumerateFiles(templatesRoot, "*.json", SearchOption.AllDirectories);

foreach (var jsonFile in jsonFiles)
{
    Console.WriteLine($"Processing: {jsonFile}");

    // Pfad-Segmente analysieren:
    // .../published/{name}/{version}/{revision}/{bugfix?}/{file}.json
    var relPath = Path.GetRelativePath(templatesRoot, jsonFile);
    var parts = relPath.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);

    if (parts.Length < 4)
    {
        Console.WriteLine($"  Skipped (unexpected path): {relPath}");
        continue;
    }

    var submodelName = parts[0];              // z.B. "Digital nameplate"
    var version = parts[1];                  // "3"
    var revision = parts[2];                 // "0"
    var bugfix = parts.Length > 4 ? parts[3] : "0"; // optional
    var fileName = Path.GetFileNameWithoutExtension(jsonFile);

    // IDTA-Nummer könntest du optional aus einer Mapping-Datei holen;
    // hier erstmal ein Platzhalter/Heuristik:
    var idtaNumber = ExtractIdtaNumberFromFileOrName(fileName);

    var className = ToSafeIdentifier($"{ToPascalCase(submodelName)}_{version}_{revision}_{bugfix}");
    var ns = $"FluentAas.Submodels.{idtaNumber}";

    // JSON nach Resources kopieren (gleiche Struktur)
    var resourceSubDir = Path.Combine(resourcesRoot, submodelName, $"{version}.{revision}.{bugfix}");
    Directory.CreateDirectory(resourceSubDir);

    var destJsonPath = Path.Combine(resourceSubDir, Path.GetFileName(jsonFile));
    File.Copy(jsonFile, destJsonPath, overwrite: true);

    // Resource-Name für EmbeddedResource-Konvention / Pfad
    var resourceName = $"FluentAas.Submodels.Resources.{SanitizeForResource(submodelName)}.{version}_{revision}_{bugfix}.{Path.GetFileName(jsonFile)}";

    var code = GenerateClassSource(ns, className, idtaNumber, submodelName, version, revision, bugfix, resourceName);

    var outDir = Path.Combine(outputRoot, idtaNumber);
    Directory.CreateDirectory(outDir);
    var outFile = Path.Combine(outDir, $"{className}.g.cs");
    File.WriteAllText(outFile, code, Encoding.UTF8);
}

Console.WriteLine("Generation finished.");


// ---------------- Helpers ----------------

static string FindRepoRoot()
{
    var dir = new DirectoryInfo(AppContext.BaseDirectory);
    while (dir != null && !File.Exists(Path.Combine(dir.FullName, ".gitignore")) && !Directory.Exists(Path.Combine(dir.FullName, ".git")))
    {
        dir = dir.Parent!;
    }

    return dir?.FullName ?? throw new InvalidOperationException("Repository root not found.");
}

static string ToSafeIdentifier(string input)
{
    var s = Regex.Replace(input, "[^A-Za-z0-9_]", "_");
    if (char.IsDigit(s[0]))
        s = "_" + s;
    return s;
}

static string ToPascalCase(string input)
{
    var parts = Regex.Split(input, "[^A-Za-z0-9]+")
        .Where(p => !string.IsNullOrWhiteSpace(p))
        .Select(p => char.ToUpperInvariant(p[0]) + p[1..].ToLowerInvariant());

    var result = string.Concat(parts);
    return string.IsNullOrEmpty(result) ? "Unnamed" : result;
}

static string SanitizeForResource(string input)
{
    return Regex.Replace(input, "[^A-Za-z0-9_]", "_");
}

// TODO: Besser aus Metadaten / Mapping auslesen
static string ExtractIdtaNumberFromFileOrName(string fileName)
{
    // Versuch, "IDTA-02006-3-0" o.ä. zu finden
    var m = Regex.Match(fileName, @"IDTA[-_]?(\d{5})");
    return m.Success ? $"IDTA{m.Groups[1].Value}" : "IDTA00000";
}

static string GenerateClassSource(
    string ns,
    string className,
    string idtaNumber,
    string submodelName,
    string version,
    string revision,
    string bugfix,
    string resourceName)
{
    return $@"// <auto-generated />
// This file was generated by FluentAas.ModelGeneration. Do not edit manually.

using FluentAas.Core.Models;
using FluentAas.IO;
using System;

namespace {ns}
{{
    /// <summary>
    /// IDTA Submodel Template: {submodelName} (IDTA {idtaNumber}, v{version}.{revision}.{bugfix})
    /// </summary>
    public static class {className}
    {{
        public const string IdtaNumber = ""{idtaNumber}"";
        public const string Name = ""{submodelName}"";
        public const int Version = {version};
        public const int Revision = {revision};
        public const int Bugfix = {bugfix};

        /// <summary>
        /// Creates a Submodel instance from the embedded IDTA JSON template.
        /// </summary>
        public static Submodel CreateTemplate(IAasJsonSerializer serializer)
        {{
            if (serializer is null) throw new ArgumentNullException(nameof(serializer));

            var assembly = typeof({className}).Assembly;
            using var stream = assembly.GetManifestResourceStream(""{resourceName}"")
                ?? throw new InvalidOperationException($""Embedded resource '{{resourceName}}' not found."");

            return serializer.DeserializeSubmodel(stream);
        }}
    }}
}}
";
}
